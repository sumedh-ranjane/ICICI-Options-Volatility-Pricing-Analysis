# -*- coding: utf-8 -*-
"""ICICIBANK.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UOsgPu6kjAZr1HHEKNCvDclsW258EqhC
"""

!pip install yfinance

import yfinance as yf
import numpy as np
import pandas as pd
import math as m
import matplotlib.pyplot as plt
import scipy
from scipy.stats import norm

data = yf.download("ICICIBANK.NS", start="2018-01-01", end="2023-01-19")
data['Close'].plot()

#Standard deviation measures how widely returns are dispersed from the average return. It’s the most common (and biased) estimator of volatility.
def standard_deviation(price_data, window=30, trading_periods=252, clean=True):

    log_return = (price_data["Close"] / price_data["Close"].shift(1)).apply(np.log)

    result = log_return.rolling(window=window, center=False).std() * m.sqrt(
        trading_periods
    )

    if clean:
        return result.dropna()
    else:
        return result

standard_deviation(data).plot()

#Parkinson’s volatility uses the stock’s high and low price of the day rather than just close to close prices. It’s useful to capture large price movements during the day.
def parkinson(price_data, window=30, trading_periods=252, clean=True):

    rs = (1.0 / (4.0 * m.log(2.0))) * (
        (price_data["High"] / price_data["Low"]).apply(np.log)
    ) ** 2.0

    def f(v):
        return (trading_periods * v.mean()) ** 0.5

    result = rs.rolling(window=window, center=False).apply(func=f)

    if clean:
        return result.dropna()
    else:
        return result

parkinson(data).plot()

#volatility measure that handles both opening jumps and drift. 
#It is the sum of the overnight volatility (close-to-open volatility) and a weighted average of open-to-close volatility. 
#The assumption of continuous prices does mean the measure tends to slightly underestimate the volatility.
def yang_zhang(price_data, window=30, trading_periods=252, clean=True):

    log_ho = (price_data["High"] / price_data["Open"]).apply(np.log)
    log_lo = (price_data["Low"] / price_data["Open"]).apply(np.log)
    log_co = (price_data["Close"] / price_data["Open"]).apply(np.log)

    log_oc = (price_data["Open"] / price_data["Close"].shift(1)).apply(np.log)
    log_oc_sq = log_oc ** 2

    log_cc = (price_data["Close"] / price_data["Close"].shift(1)).apply(np.log)
    log_cc_sq = log_cc ** 2

    rs = log_ho * (log_ho - log_co) + log_lo * (log_lo - log_co)

    close_vol = log_cc_sq.rolling(window=window, center=False).sum() * (
        1.0 / (window - 1.0)
    )
    open_vol = log_oc_sq.rolling(window=window, center=False).sum() * (
        1.0 / (window - 1.0)
    )
    window_rs = rs.rolling(window=window, center=False).sum() * (1.0 / (window - 1.0))

    k = 0.34 / (1.34 + (window + 1) / (window - 1))
    result = (open_vol + k * close_vol + (1 - k) * window_rs).apply(
        np.sqrt
    ) * m.sqrt(trading_periods)

    if clean:
        return result.dropna()
    else:
        return result

yang_zhang(data).plot()

#Defining Black Schole Model
def option_value(option_type, S, K, sigma, t=0, r=0):
    """
    Calculate the value of an option using the Black-Scholes model
    
    :param option_type: "call"/"c" or "put"/"p"
    :type option_type: str
    :param S: price of the underlying
    :type S: float
    :param K: strike price of option
    :type K: float
    :param sigma: input implied volatility
    :type sigma: float
    :param t: time to expiration
    :type t: float, optional
    :param r: risk-free rate
    :type r: float, optional
    """
    with np.errstate(divide='ignore'):
        d1 = np.divide(1, sigma * np.sqrt(t)) * (np.log(S/K) + (r+sigma**2 / 2) * t)
        d2 = d1 - sigma * np.sqrt(t)
    if option_type.lower() in {"c", "call"}:
        return np.multiply(norm.cdf(d1),S) - np.multiply(norm.cdf(d2), K * np.exp(-r * t))
    elif option_type.lower() in {"p", "put"}:
        return -np.multiply(norm.cdf(-d1), S) + np.multiply(norm.cdf(-d2), K * np.exp(-r * t))

# Construction of a butterfly spread
S = np.linspace(50, 150, 1000)
C1 = option_value("c", S, 90, sigma=0.20)
C2 = -option_value("c", S, 100, sigma=0.20)
C3 = option_value("c", S, 110, sigma=0.20)
butterfly = C1 + 2 * C2 + C3

# (Gross) payoff diagram
fig, (ax, ax1) = plt.subplots(1,2, figsize=(12,4), sharey=True)
ax.plot(S, C1, S, C2, S, C3)
ax.set_xlabel("Stock price at expiration")
ax.set_ylabel("Gross payoff")
ax.legend(["long call, 860 strike", "2x short call, $870 strike", "long call, $880 strike"], loc="best")

ax1.plot(S, butterfly, c="m")
ax1.legend(["long butterfly"], loc="upper left")
# plt.show();
plt.savefig("long_butterfly.png", dpi=200)

from google.colab import files
uploaded = files.upload()

Call = pd.read_excel(uploaded.get('ICICI Call.xlsx'))
Call

Put = pd.read_excel(uploaded.get('ICICI Put.xlsx'))
Put

Put.isnull().sum()

# Find midprices from bid/asks
Call["midprice"] = (Call.BID + Call.ASK)/2
Call = Call[Call.midprice > 0]
Put["midprice"] = (Put.BID + Put.ASK)/2
Put = Put[Put.midprice > 0]
Call.tail(30)

Call.iloc[:50].reset_index(drop=True)

Put.head(10)

# Visualise put and call prices
fig, (ax0, ax1) = plt.subplots(1, 2, figsize=(12,6))
ax0.scatter(Call.STRIKE, Call.midprice);
ax1.scatter(Put.STRIKE, Put.midprice);
plt.show()

# Construct butterflies
data = []

for (_, left) ,(_,centre), (_, right) in zip(Call.iterrows(), Call.iloc[1:].iterrows(), Call.iloc[2:].iterrows()):
    # Filter out all zero volume
    if not any(vol > 0 for vol in {left.VOLUME, centre.VOLUME, right.VOLUME}):
        continue
    # Filter out any zero open interest
    if not all(oi > 0 for oi in {left.OI, centre.OI, right.OI}):
        continue
    # Equidistant on either end
    if centre.STRIKE - left.STRIKE != right.STRIKE - centre.STRIKE:
        continue
    butterfly_price = left.midprice - 2* centre.midprice + right.midprice
    max_profit = centre.STRIKE - left.STRIKE
    data.append([centre.STRIKE, butterfly_price, max_profit])

bflys = pd.DataFrame(data, columns=["strike", "price", "max_profit"])
bflys["prob"] = bflys.price / bflys.max_profit
bflys

# ICICIBANK was trading around 921.75 when this data was collected
plt.rcParams.update({'font.size': 16})
plt.figure(figsize=(9,6))
plt.scatter(bflys.strike, bflys.prob);
plt.xlabel("Strike")
plt.ylabel("Probability")
plt.show()
# plt.savefig("ICICIBANK_raw_bfly_prob.png", dpi=300)

from scipy.ndimage import gaussian_filter1d

smoothed_prob = gaussian_filter1d(bflys.prob, 2)

plt.figure(figsize=(9,6))
plt.plot(bflys.strike, bflys.prob, "o", bflys.strike, smoothed_prob, "rx")
plt.legend(["raw prob", "smoothed prob"], loc="best")
plt.xlabel("Strike")
plt.ylabel("Probability")
plt.show()
# plt.savefig("ICICIBANK_smooth_bfly_prob.png", dpi=300)

plt.figure(figsize=(9,6))
pdf = scipy.interpolate.interp1d(bflys.strike, smoothed_prob, kind="cubic",
                                 fill_value="extrapolate")
x_new = np.linspace(bflys.strike.min(), bflys.strike.max(), 100)
plt.plot(bflys.strike, smoothed_prob, "rx", x_new, pdf(x_new), "k-");
plt.legend(["smoothed prob", "fitted PDF"], loc="best")
plt.xlabel("K")
plt.ylabel("f(K)")
plt.tight_layout()
plt.show()
# plt.savefig("ICICIBANK_bfly_pdf.png", dpi=300)

# Find area under curve
raw_total_prob = scipy.integrate.trapz(smoothed_prob, bflys.strike)
print(f"Raw total probability: {raw_total_prob}")
normalised_prob = smoothed_prob / raw_total_prob
total_prob = scipy.integrate.trapz(normalised_prob, bflys.strike)
print(f"Normalised total probability: {total_prob}")
# Don't need to normalise because there is mass in the left tail that we are ignoring

# # Normalise
# normalised_prob = smoothed_prob / raw_total_prob
# total_prob = scipy.integrate.trapz(normalised_prob, bflys.strike)
# print(f"Normalised total probability: {total_prob}")
# # should be less than 1

# Repeating the same with put butterflies
from scipy.ndimage import gaussian_filter1d

data = []

for (_, left) ,(_,centre), (_, right) in zip(Put.iterrows(), Put.iloc[1:].iterrows(), Put.iloc[2:].iterrows()):
    # Filter out all zero volume
    if not any(vol > 0 for vol in {left.VOLUME, centre.VOLUME, right.VOLUME}):
        continue
    # Filter out any zero open interest
    if not all(oi > 0 for oi in {left.OI, centre.OI, right.OI}):
        continue
    # Equidistant on either end
    if centre.STRIKE - left.STRIKE != right.STRIKE - centre.STRIKE:
        continue
    butterfly_price = left.midprice - 2* centre.midprice + right.midprice
    max_profit = centre.STRIKE - left.STRIKE
    data.append([centre.STRIKE, butterfly_price, max_profit])

put_bflys = pd.DataFrame(data, columns=["strike", "price", "max_profit"])
put_bflys["prob"] = put_bflys.price / put_bflys.max_profit
smoothed_prob_put = gaussian_filter1d(put_bflys.prob, 2)
plt.plot(put_bflys.strike, put_bflys.prob, "o", put_bflys.strike, smoothed_prob_put, "rx")
plt.legend(["raw prob", "smoothed prob"], loc="best")
plt.show()

put_pdf = scipy.interpolate.interp1d(put_bflys.strike, smoothed_prob_put, kind="cubic", 
                                     fill_value=0.0)
x_new = np.linspace(bflys.strike.min(), put_bflys.strike.max(), 100)
plt.plot(x_new, pdf(x_new), "m-", x_new, put_pdf(x_new), "k-");
plt.legend(["call PDF", "put PDF"], loc="best")
plt.show()

def construct_pdf(calls_df, make_plot=True, fill_value="extrapolate"):
    if "midprice" not in calls_df.columns:
        calls_df["midprice"] = (calls_df.bid + calls_df.ask) /2
    
    # Construct butterflies
    data = []

    for (_, left) ,(_,centre), (_, right) in zip(calls_df.iterrows(), calls_df.iloc[1:].iterrows(), calls_df.iloc[2:].iterrows()):
        # Filter out all zero volume
        if not any(vol > 0 for vol in {left.VOLUME, centre.VOLUME, right.VOLUME}):
            continue
        # Filter out any zero open interest
        if not all(oi > 0 for oi in {left.OI, centre.OI, right.OI}):
            continue
        # Equidistant on either end
        if centre.STRIKE - left.STRIKE != right.STRIKE - centre.STRIKE:
            continue
        butterfly_price = left.midprice - 2* centre.midprice + right.midprice
        max_profit = centre.STRIKE - left.STRIKE
        data.append([centre.STRIKE, butterfly_price, max_profit])

    bflys = pd.DataFrame(data, columns=["strike", "price", "max_profit"])
    bflys["prob"] = bflys.price / bflys.max_profit

    smoothed_prob = gaussian_filter1d(bflys.prob, 2)
    pdf = scipy.interpolate.interp1d(bflys.strike, smoothed_prob, kind="cubic",
                                     fill_value=fill_value)
    if not make_plot:
        return pdf
    
    plt.figure(figsize=(9,6))
    x_new = np.linspace(bflys.strike.min(), bflys.strike.max(), 100)
    plt.plot(bflys.strike, smoothed_prob, "rx", x_new, pdf(x_new), "k-");
    plt.legend(["smoothed prob", "fitted PDF"], loc="best")
    plt.xlabel("K")
    plt.ylabel("f(K)")

#Implied PDF from Breeden-Litzenberger
Call["midprice"] = (Call.BID + Call.ASK)/2
Call = Call[Call.midprice > 0]
Call

Call_sub = Call[(Call.STRIKE > 580) & (Call.STRIKE < 1090)]
plt.figure(figsize=(12,6))
plt.plot(Call_sub.STRIKE, Call_sub.midprice, ".");
plt.xlabel("STRIKE")
plt.ylabel("price")
plt.savefig("call_prices.png", dpi=400)
plt.show()

def call_value(S, K, sigma, t=0, r=0):
    # use np.multiply and divide to handle divide-by-zero
    with np.errstate(divide='ignore'):
        d1 = np.divide(1, sigma * np.sqrt(t)) * (np.log(S/K) + (r+sigma**2 / 2) * t)
        d2 = d1 - sigma * np.sqrt(t)
    return np.multiply(norm.cdf(d1),S) - np.multiply(norm.cdf(d2), K * np.exp(-r * t))

def call_vega(S, K, sigma, t=0, r=0):
    with np.errstate(divide='ignore'):
        d1 = np.divide(1, sigma * np.sqrt(t)) * (np.log(S/K) + (r+sigma**2 / 2) * t)
    return np.multiply(S, norm.pdf(d1)) * np.sqrt(t)

def bs_iv(price, S, K, t=0, r=0, precision=1e-4, initial_guess=0.2, max_iter=1000, verbose=False):
    iv = initial_guess
    for _ in range(max_iter):
        P = call_value(S, K, iv, t, r)
        diff = price - P
        if abs(diff) < precision:
            return iv
        grad = call_vega(S, K, iv, t, r)
        iv += diff/grad     
    if verbose:
        print(f"Did not converge after {max_iter} iterations")
    return iv

c_test = call_value(871.65, 860, 0.2, t=1/52)
print(c_test)

bs_iv(c_test, 871.65,860, t=1/52)

S = 871.65
t = 1/52
Call["iv"] = Call.apply(lambda row: bs_iv(row.midprice, S, row.STRIKE, t, max_iter=500), axis=1)

def plot_vol_smile(Call, savefig=False):
    plt.figure(figsize=(9,6))
    plt.plot(Call.STRIKE, Call.iv, ".")
    plt.xlabel("Strike")
    plt.ylabel("IV")
    if savefig:
        plt.savefig("vol_smile.png",dpi=300)
    plt.show()

Call_no_na = Call.dropna()

fig, (ax1, ax2) = plt.subplots(2,1, figsize=(6,7), sharex=True)
ax1.plot(Call_no_na.STRIKE, Call_no_na.midprice, "r.")
ax1.set_ylabel("Call price")
ax2.plot(Call_no_na.STRIKE, Call_no_na.iv, ".")
ax2.set_ylabel("IV")
ax2.set_xlabel("Strike")
plt.tight_layout()
# plt.savefig("calls_to_iv.png", dpi=400)
plt.show()

Call_clean = Call.dropna().copy()
Call_clean["iv"] = gaussian_filter1d(Call_clean.iv, 2)

plot_vol_smile(Call_clean)

Call_clean = Call_clean[(Call_clean.STRIKE > 790) & (Call_clean.STRIKE < 1000)]

plot_vol_smile(Call_clean, savefig=False)

plt.figure(figsize=(9,6))
vol_surface = scipy.interpolate.interp1d(Call_clean.STRIKE, Call_clean.iv, kind="cubic",
                                 fill_value="extrapolate")
x_new = np.arange(Call_clean.STRIKE.min(), Call_clean.STRIKE.max(), 0.1)
plt.plot(Call_clean.STRIKE, Call_clean.iv, "bx", x_new, vol_surface(x_new), "k-");
plt.legend(["smoothed IV", "fitted smile"], loc="best")
plt.xlabel("Strike")
plt.ylabel("IV")
plt.tight_layout()
# plt.savefig("SPY_smile.png", dpi=300)
plt.show()

C_interp = call_value(S, x_new, vol_surface(x_new), t)

first_deriv = np.gradient(C_interp, x_new)
second_deriv = np.gradient(first_deriv, x_new)

def pdf2(Krange, S, t=0, r=0):
    # x is a range of strikes
    Crange = call_value(S, Krange, vol_surface(Krange), t, r)
    first_deriv = np.gradient(Crange, x_new, edge_order=0)
    second_deriv = np.gradient(first_deriv, x_new, edge_order=0)
    return np.exp(r * t) * second_deriv

fig, ax1 = plt.subplots(figsize=(9,6))

col="slategrey"
ax1.set_xlabel('Strike')
ax1.set_ylabel('Call price', color=col)
ax1.plot(x_new, C_interp, color=col)
ax1.tick_params(axis='y', labelcolor=col)
ax1.axvline(871.65, color="k", linestyle="--")

ax2 = ax1.twinx()
col = 'darkred'
ax2.set_ylabel('f(K)', color=col)
ax2.plot(x_new, pdf2(x_new, S, t), color=col)
ax2.tick_params(axis='y', labelcolor=col)

fig.tight_layout()
# plt.savefig("volspace_pdf.png", dpi=300)
plt.show()

data = np.vstack([x_new, pdf(x_new), pdf2(x_new, S, t)]).T
data = data[(data[:, 0] < 950) & (data[:, 0] > 890)]
k, bfly_pdf, curve_pdf = np.hsplit(data,3)

plt.figure(figsize=(9,6))
plt.plot(k, bfly_pdf, "steelblue", k, curve_pdf, "darkred")
plt.xlabel("Strike")
plt.ylabel("f(K)")
plt.legend(["Butterfly PDF", "Breeden-Litzenberger PDF"], loc="best")
# plt.savefig("butterfly_vs_breeden.png", dpi=300)
plt.show()

Call["price_clean"] = gaussian_filter1d(Call.midprice, 3)
price_interp = scipy.interpolate.interp1d(Call.STRIKE, Call.price_clean, kind="cubic",
                                 fill_value="extrapolate")
C_interp_direct = price_interp(x_new)

plt.plot(x_new, C_interp - C_interp_direct)
plt.xlabel("Strike")
plt.ylabel("Vol space - call space")
plt.show()

def pdf3(Call, Krange, S, t=0, r=0):
    # x is a range of strikes
    Call["price_clean"] = gaussian_filter1d(Call.midprice, 3)
    price_interp = scipy.interpolate.interp1d(Call.STRIKE, Call.price_clean, kind="cubic",
                                     fill_value="extrapolate")
    Crange = price_interp(Krange)
    first_deriv = np.gradient(Crange, x_new, edge_order=0)
    second_deriv = np.gradient(first_deriv, x_new, edge_order=0)
    return second_deriv

plt.figure(figsize=(9,6))
plt.plot(x_new, pdf3(Call, x_new, S, t), "darkgreen", x_new, pdf2(x_new, S, t), "darkred")
plt.xlabel("Strike")
plt.ylabel("f(K)")
plt.legend(["Price-space PDF", "IV-space PDF"], loc="best")
# plt.savefig("price_vol_comparison.png", dpi=300)
plt.show()

plt.plot(x_new, pdf2(x_new, S, t) - pdf3(Call, x_new, S, t), "r--");
plt.xlabel("Strike")
plt.ylabel("Vol-space PDF - price-space PDF")
plt.show()

